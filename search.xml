<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「数学」Dandelin spheres 更好的理解椭圆</title>
      <link href="/2022/11/06/Dandelin-spheres/"/>
      <url>/2022/11/06/Dandelin-spheres/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Dandelin spheres</p><blockquote><p>对于椭圆，并不陌生</p><p>我大概简单梳理了一下大概有三种定义</p><ol><li>从圆对与xy轴的变换</li><li>一条绳子通过两个图钉进行绘画</li><li>圆锥的切面</li></ol></blockquote><p>这三个定义之间有什么样的联系我们需要去思考</p><h2 id="所以为什么圆锥的切面就会是椭圆呢？"><a href="#所以为什么圆锥的切面就会是椭圆呢？" class="headerlink" title="所以为什么圆锥的切面就会是椭圆呢？"></a>所以为什么圆锥的切面就会是椭圆呢？</h2><p>在这里我们引入：丹德林球体</p><p>主要条件无不是创建一个相切的条件</p><p><a href="https://en.wikipedia.org/wiki/File:Dandelin_spheres.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/Dandelin_spheres.svg/330px-Dandelin_spheres.svg.png" alt="img"></a></p><h3 id="解决本题的关键是什么呢？"><a href="#解决本题的关键是什么呢？" class="headerlink" title="解决本题的关键是什么呢？"></a>解决本题的关键是什么呢？</h3><p>主要是根据椭圆的其他定义，连线相加是一个固定值。</p><p><strong>所以我们的关键是：「于变化中寻找不变量」</strong></p><h3 id="何谓不变量？"><a href="#何谓不变量？" class="headerlink" title="何谓不变量？"></a>何谓不变量？</h3><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221106202146068.png" alt="image-20221106202146068"></p><h3 id="所以我们需要寻找一种方法将椭圆的“图钉连线”转换到圆锥的侧面上。"><a href="#所以我们需要寻找一种方法将椭圆的“图钉连线”转换到圆锥的侧面上。" class="headerlink" title="所以我们需要寻找一种方法将椭圆的“图钉连线”转换到圆锥的侧面上。"></a>所以我们需要寻找一种方法将椭圆的“图钉连线”转换到圆锥的侧面上。</h3><p>这时候相切条件就非常重要了</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221106203150231.png" alt="image-20221106203150231"></p><h4 id="严谨的解释如下："><a href="#严谨的解释如下：" class="headerlink" title="严谨的解释如下："></a>严谨的解释如下：</h4><p>设 S 为此圆锥的顶点，平面 <em>e</em> 与此圆锥交于曲线 <em>C</em>（蓝色区域）。 以下则证明 <em>C</em> 是椭圆。</p><p>放置两个棕色的丹德林球<em>G</em>1 和 <em>G</em>2，皆与平面和圆锥相交，上面的为<em>G</em>1，下面的为<em>G</em>2。 而两个球体与锥体相切的点形成圆形（白色的部分），分别记为k1 and k2。</p><p>将 <em>G</em>1 与此平面的切点记为 <em>F</em>1 ；类似地，用于<em>G</em>2 与<em>F</em>2。<em>P</em> 为曲线 <em>C</em> 上一点 。</p><p><em>需要证明</em>：当 <em>P</em> 沿着截面曲线 <em>C</em> 移动时，d(P,F1)+d(P,F2) 仍是定值（椭圆的定义之一)。</p><ul><li><p>将 <em>P</em> 与圆锥顶点 <em>S</em> 作一直线，与 <em>G</em>1 和 <em>G</em>2 分别交于 <em>P</em>1 和 <em>P</em>2 。</p></li><li><p>将 <em>P</em> 移动时，<em>P</em>1 和 <em>P</em>2 则沿着两个圆移动，且其距离 d(P1,P2) 是定值。</p></li><li><p><em>P</em> 和 <em>F</em>1 的距离会等同于 <em>P</em> 到 <em>P</em>1 的距离，因为线段 | <em>PF</em>1 and <em>PP</em>1 都相切于<em>G</em>1。</p></li><li><p>基于对称性，<em>P</em> 到 <em>F</em>2 的距离，等于 <em>P</em> 到 <em>P</em>2 的距离，因为线段 | <em>PF</em>2 和 <em>PP</em>2 都<a href="https://zh.wikipedia.org/wiki/%E7%9B%B8%E5%88%87">相切</a>于<em>G</em>2</p></li><li><p>于是，我们计算出其距离和 d(P,F1)+d(P,F2) &#x3D; d(P,P1)+d(P,P2) &#x3D; d(P1,P2) 是定值。</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「密码学」二维码与RS码</title>
      <link href="/2022/11/06/RS%E7%A0%81/"/>
      <url>/2022/11/06/RS%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="译-为程序员写的Reed-Solomon码解释-Felix021-So-far-so-good"><a href="#译-为程序员写的Reed-Solomon码解释-Felix021-So-far-so-good" class="headerlink" title="[译] 为程序员写的Reed-Solomon码解释 - Felix021 - So far so good"></a>[<a href="https://www.felix021.com/blog/read.php?2116">译] 为程序员写的Reed-Solomon码解释 - Felix021 - So far so good</a></h2><blockquote><p>一点阅读过程中有点感触就想写点</p></blockquote><h2 id="RS码的历史"><a href="#RS码的历史" class="headerlink" title="RS码的历史"></a>RS码的历史</h2><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030222511963.png" alt="image-20221030222511963"></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>看RS码主要是再github上那个zxing生成二维码的项目</p><p>看源码的时候遇到了较大的困难，主要来自数学层面，于是到互联网上搜集资料找到了这一篇</p><h2 id="从程序员的视角"><a href="#从程序员的视角" class="headerlink" title="从程序员的视角"></a>从程序员的视角</h2><h4 id="QR码结构"><a href="#QR码结构" class="headerlink" title="QR码结构"></a>QR码结构</h4><p>在角落的3个方形定位器模式是QR码的典型可见特征</p><p><img src="https://upload-images.jianshu.io/upload_images/3071283-cae1182d137db6d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/368/format/webp" alt="img"></p><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>掩码处理：逆转某些模块（白色变成黑色，黑色变成白色），保留其他模块不变。</p><p>目的：为了避免数据区域中出现诸如类似定位器模式的形状，或者是大片的空白区域等，可能会使扫描器混淆、错乱。</p><p><img src="https://upload-images.jianshu.io/upload_images/3071283-d1927f454c1996b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp" alt="img"></p><p>红色区域使用一个固定的掩码模式编码保存了数据区域（黑白部分）的掩码格式信息。</p><blockquote><p>其实可以理解成，掩码就是一个有固定格式的点阵图，点阵图上的标记可以让黑白进行转换</p></blockquote><h4 id="掩码使用什么操作"><a href="#掩码使用什么操作" class="headerlink" title="掩码使用什么操作"></a>掩码使用什么操作</h4><p>使用异或运算（XOR，eXclusive-or，通常在变成语言中用 ^ 来表示）</p><h4 id="具体是怎么样的"><a href="#具体是怎么样的" class="headerlink" title="具体是怎么样的"></a>具体是怎么样的</h4><ol><li><p>逆时针读取左上角的定位器模式</p></li><li><p>得到下面的比特序列，白色表示0，黑色表示1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input   101101101001011</span><br><span class="line">Mask  ^ 101010000010010</span><br><span class="line">Output  000111101011001</span><br></pre></td></tr></table></figure></li></ol><h5 id="格式信息"><a href="#格式信息" class="headerlink" title="格式信息"></a>格式信息</h5><blockquote><p>格式信息有另一份可辨别的副本，因此即使其中一份被毁坏，也仍然有机会被识别</p></blockquote><p>副本被分成两个部分，分别放在另外两个定位器的边上，同样也是逆时针方向阅读（沿着左下角定位器往上，然后是右上角定位器边缘从左往右）。</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027210323174.png" alt="image-20221027210323174"></p><h4 id="格式信息的前2-bits-给出了用于数据的纠错级别。"><a href="#格式信息的前2-bits-给出了用于数据的纠错级别。" class="headerlink" title="格式信息的前2 bits 给出了用于数据的纠错级别。"></a>格式信息的前2 <em>bits</em> 给出了用于数据的纠错级别。</h4><p>这个尺寸的QR码包含26字节(<em>bytes</em>,1 <em>byte</em> &#x3D; 8 <em>bits</em> )信息，其中一些用于保存原数据，一些用于保存校验码，如下表所示。左边第一列只是给纠错级别起了个简单的名字。</p><table><thead><tr><th align="center">纠错级别</th><th align="center">级别指示器</th><th align="center">纠错码字节数</th><th align="center">原数据字节数</th></tr></thead><tbody><tr><td align="center">L</td><td align="center">01</td><td align="center">7</td><td align="center">19</td></tr><tr><td align="center">M</td><td align="center">00</td><td align="center">10</td><td align="center">16</td></tr><tr><td align="center">Q</td><td align="center">11</td><td align="center">13</td><td align="center">13</td></tr><tr><td align="center">H</td><td align="center">10</td><td align="center">17</td><td align="center">9</td></tr></tbody></table><h4 id="格式信息中的接下来3-bits用于指定对数据区域使用的掩码模式。"><a href="#格式信息中的接下来3-bits用于指定对数据区域使用的掩码模式。" class="headerlink" title="格式信息中的接下来3 bits用于指定对数据区域使用的掩码模式。"></a>格式信息中的接下来3 <em>bits</em>用于指定对数据区域使用的掩码模式。</h4><p>掩码模式使用6*6方格，根据需要覆盖区域进行掩码计算</p><p>下方的计算式i，j分别表示行列（从左上角算起）</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027201918347.png" alt="image-20221027201918347"></p><h4 id="格式信息中剩下的10-bits-是用于对格式信息本身的错误校验"><a href="#格式信息中剩下的10-bits-是用于对格式信息本身的错误校验" class="headerlink" title="格式信息中剩下的10 bits 是用于对格式信息本身的错误校验"></a>格式信息中剩下的10 <em>bits</em> 是用于对格式信息本身的错误校验</h4><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="反掩码操作后的的图样"><a href="#反掩码操作后的的图样" class="headerlink" title="反掩码操作后的的图样"></a>反掩码操作后的的图样</h3><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027202239375.png" alt="image-20221027202239375"></p><h3 id="数据如何读取"><a href="#数据如何读取" class="headerlink" title="数据如何读取"></a>数据如何读取</h3><h4 id="从右下角开始，沿着最右边的两列向上走“之”字形"><a href="#从右下角开始，沿着最右边的两列向上走“之”字形" class="headerlink" title="从右下角开始，沿着最右边的两列向上走“之”字形"></a>从右下角开始，沿着最右边的两列向上走“之”字形</h4><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027202421447.png" alt="image-20221027202421447"></p><p>前三个字节分别是 01000000 11010010 01110101</p><p>一个字节Bytes&#x3D;8bit</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027202459121.png" alt="image-20221027202459121"></p><h4 id="接下来两列从上向下读取，当读取到底部后，再反过来从下往上读取接下来两列"><a href="#接下来两列从上向下读取，当读取到底部后，再反过来从下往上读取接下来两列" class="headerlink" title="接下来两列从上向下读取，当读取到底部后，再反过来从下往上读取接下来两列"></a>接下来两列从上向下读取，当读取到底部后，再反过来从下往上读取接下来两列</h4><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027202701684.png" alt="image-20221027202701684"></p><h4 id="纠错码读取方式和原来一样"><a href="#纠错码读取方式和原来一样" class="headerlink" title="纠错码读取方式和原来一样"></a>纠错码读取方式和原来一样</h4><p>一直读到最左边的列</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027202759707.png" alt="image-20221027202759707"></p><h4 id="十六进制表示的数据："><a href="#十六进制表示的数据：" class="headerlink" title="十六进制表示的数据："></a>十六进制表示的数据：</h4><p>进制转换</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027203047352.png" alt="image-20221027203047352"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">二进制：</span><br><span class="line">原始信息:</span><br><span class="line">0100000011010010011101010100--7   0111011101100001011100110010--7</span><br><span class="line">011000100111001001101001--6</span><br><span class="line">011011000110110001101001--6</span><br><span class="line">01100111000011101100--5</span><br><span class="line"></span><br><span class="line">错误纠正:001010101001000000010011011010111010111111101111111111000000000000000000....</span><br><span class="line">原始信息: 40 d2 75 47 76 17 32 06 27 26 96 c6 c6 96 70 ec</span><br><span class="line">错误纠正: bc 2a 90 13 6b af ef fd 4b e0</span><br></pre></td></tr></table></figure><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><h3 id="将信息解码成可读格式"><a href="#将信息解码成可读格式" class="headerlink" title="将信息解码成可读格式"></a>将信息解码成可读格式</h3><p>前4 <em>bits</em> 指明了信息是如何编码的</p><h4 id="QR码的编码方案"><a href="#QR码的编码方案" class="headerlink" title="QR码的编码方案"></a>QR码的编码方案</h4><table><thead><tr><th align="center">方案名称</th><th align="center">模式指示器</th><th align="center">长度字节数</th><th align="center">数据字节数</th></tr></thead><tbody><tr><td align="center">数字</td><td align="center">0001</td><td align="center">10</td><td align="center">10 <em>bits</em> per 3 digits</td></tr><tr><td align="center">字母数字</td><td align="center">0010</td><td align="center">9</td><td align="center">11 <em>bits</em> per 2 characters</td></tr><tr><td align="center">字节</td><td align="center">0100</td><td align="center">8</td><td align="center">8 <em>bits</em> per character</td></tr><tr><td align="center">汉字</td><td align="center">1000</td><td align="center">8</td><td align="center">13 <em>bits</em> per character</td></tr></tbody></table><p>我们的样例数据开头是 0100表明接下来是每个字符8 <em>bits</em>，接下来8 <em>bits</em> 是长度字段</p><p>00001101——-转为10进制——-13（8+4+1）</p><p>表明有13个字符之后才是数据字符</p><p>前两个是00100111和01010100（对于ASCII字符 ‘ 和 T）</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027204733677.png" alt="image-20221027204733677"></p><p>使用微信扫扫看</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/de349945566f64b9a25c4d344414d84.jpg" alt="de349945566f64b9a25c4d344414d84"></p><p><strong>验证了对于ASCII字符 ‘ 和 T以及一共13个字符</strong></p><p>在数据 <em>bit</em> 之后是另外一个4 <em>bit</em> 模式指示器</p><p>可以跟前一个不同，从而允许在一个QR码中混合多个编码方案。如果没有其他数据了，用 0000 来标记结尾（注意，标准允许忽略这个标记，如果存储空间不够的话）。</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027210212414.png" alt="image-20221027210212414"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一下：从二维码的视觉识别方法到RS码到BCH码,是一个编解码方法逐步追求本质的过程，下一节内容是关于BCH码以及Hamming code的详细分析，欢迎各位阅读。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「密码学」BCH与HammingCode</title>
      <link href="/2022/11/06/BCH%E4%B8%8EHammingCode/"/>
      <url>/2022/11/06/BCH%E4%B8%8EHammingCode/</url>
      
        <content type="html"><![CDATA[<p><strong>Bose–Chaudhuri–Hocquenghem codes</strong></p><p>BCH代码是里德- 所罗门代码的推广</p><h3 id="我们可以尝试把二进制数表示为多项式"><a href="#我们可以尝试把二进制数表示为多项式" class="headerlink" title="我们可以尝试把二进制数表示为多项式"></a>我们可以尝试把二进制数表示为多项式</h3><p>例如11011表示成为<br>$$<br>1+x+x^3+x^4<br>$$</p><p>计算11*11，在多项式表示<br>$$<br>(1+x)∗(1+x)&#x3D;1+2∗x+x^2&#x3D;1+x^2<br>$$<br>这儿的x的系数2在二进制中等于0</p><p>另外很重要的概念就是二进制域中，加等于减<br>$$<br>x^2+1 &#x3D;0相当于x^2 &#x3D; 1<br>$$</p><h6 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h6><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027220342073.png" alt="image-20221027220342073"></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027220743056.png" alt="image-20221027220743056"></p><h3 id="BCH的出现"><a href="#BCH的出现" class="headerlink" title="BCH的出现"></a>BCH的出现</h3><h4 id="多位错误"><a href="#多位错误" class="headerlink" title="多位错误"></a>多位错误</h4><p>我们先回顾简单的奇偶校验码和hamming码。简单的奇偶校验码只能检查出错误而不知道具体是哪里出错，而hamming码只能纠正一位错误。因此我们想能不能有一种方法可以纠正多位错误呢？</p><ol><li>假如我们的真正的消息是m(x)</li><li>乘上一个编码多项式p(x)，</li><li>得到m(x)p(x)再将其发送过去。</li><li>多项式被加上错误多项式e(x)，</li><li>接收者接收者的消息为c(x)</li></ol><p>$$<br>c(x)&#x3D;m(x)p(x)+e(x)<br>$$</p><h4 id="纠单个错方法"><a href="#纠单个错方法" class="headerlink" title="纠单个错方法"></a>纠单个错方法</h4><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><p><strong>p(x)必须是不可约的本原多项式(primitive polynomials)</strong></p><h5 id="寻找本原多项式"><a href="#寻找本原多项式" class="headerlink" title="寻找本原多项式"></a>寻找本原多项式</h5><blockquote><p>让e(x)不被除尽</p></blockquote><ul><li><p>r次多项式，最高次项x^r的系数必须是1。</p></li><li><p>多项式如果不包含常数项1，就会被x整除。</p></li><li><p>多项式项数不能是偶数的，比如<br>$$<br>1 + x + x^2 + x^41 + x + x^2 + x^4<br>$$<br>有四项，很容易将其分解为<br>$$<br>(1 + x)(1 + x^2)(1 + x)(1 + x^2)<br>$$</p></li><li><p>每一项的次数也不能都是偶数，否则将每一项次数减半就能得到因子。例如<br>$$<br>1 + x^2 + x^4 &#x3D; (1 + x + x^2)^2<br>$$</p></li></ul><p>和发送者商量好p(x)</p><p>让c(x)除以p(x)，</p><ol><li><p>如果余项是0，即没有e(x)，没有受到干扰，那么商就是m(x)，就是正确的消息。</p></li><li><p>如果余项不是零，我们的商就变成了m(x) + e(x)&#x2F;p(x)，无法将真正的消息分离出来。</p><h5 id="本原多项式"><a href="#本原多项式" class="headerlink" title="本原多项式"></a><strong>本原多项式</strong></h5></li></ol><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-44b203b9f80b2a857fca1aa92f787c53_720w.webp" alt="img"></p><h4 id="纠正多个错误"><a href="#纠正多个错误" class="headerlink" title="纠正多个错误"></a>纠正多个错误</h4><h5 id="BCH码"><a href="#BCH码" class="headerlink" title="BCH码"></a>BCH码</h5><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-bb2cbac64a88307e27de57009bee91e4_720w.webp" alt="img"></p><ol><li>p(x)是本原多项式</li><li>p3(x3)…都是可以被p(x)除余0的多项式</li></ol><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-b1b0631c114f9b8dcc75381133c3c1b6_720w.webp" alt="img"></p><h5 id="可以纠正两个错误的编码多项式"><a href="#可以纠正两个错误的编码多项式" class="headerlink" title="可以纠正两个错误的编码多项式"></a>可以纠正两个错误的编码多项式</h5><p>$$<br>Q(x) &#x3D; p(x)p3(x)<br>$$</p><h5 id="纠正三个错误的编码多项式"><a href="#纠正三个错误的编码多项式" class="headerlink" title="纠正三个错误的编码多项式"></a>纠正三个错误的编码多项式</h5><p>$$<br>Q(x) &#x3D; p(x)p3(x)p5(x)<br>$$</p><p>eg.纠正两个错误<br>$$<br>p(x) &#x3D; 1 + x + x^4<br>$$<br>可以看出<br>$$<br>(x^6 + x^9 + x^12) &#x3D; 1 + x^3 (mod \space p(x))<br>$$<br>模二除法</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/0ef1910781ec28df9c0c7af16019a89.jpg" alt="0ef1910781ec28df9c0c7af16019a89"></p><p>得1001余数就是1 + x^3</p><p>将1+x3移到左边<br>$$<br>p3(x) &#x3D; 1 + x + x^2 + x^3 + x^4<br>$$<br>以此为方法可以得出<br>$$<br>p5(x) &#x3D; 1 + x + x^2<br>$$</p><h6 id="编码多项式如下"><a href="#编码多项式如下" class="headerlink" title="编码多项式如下"></a>编码多项式如下</h6><p>$$<br>Q(x) &#x3D; p(x)p3(x)p5(x) &#x3D; ( 1 + x + x^4 )( 1+x + x^2 + x^3 + x^4 )(1 + x + x^2)&#x3D; 1 + x^2 + x^3 + x^4 + x^5 + x^8 + x^10<br>$$</p><p>表示成二进制是11101100101</p><p>再乘上消息m(x)就是100001110110010，就是我们发送的出去的</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-f9d7c6758ad7dd91ffb34ad2d04206ff_r.jpg"></p><h6 id="设：现在接收者受到的r-x-却是-101000110110010"><a href="#设：现在接收者受到的r-x-却是-101000110110010" class="headerlink" title="设：现在接收者受到的r(x)却是 101000110110010"></a>设：现在接收者受到的r(x)却是 10<strong>1</strong>00<strong>0</strong>110110010</h6><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-7f444c31e69d826832c2a4613bf0a119_r.jpg"></p><p>前两项余项不为0，而第三项为0说明接到的只有两处错误。</p><h6 id="开始用错误定位多项式（-error-locator-polynomial-）"><a href="#开始用错误定位多项式（-error-locator-polynomial-）" class="headerlink" title="开始用错误定位多项式（ error locator polynomial ）"></a>开始用错误定位多项式（ error locator polynomial ）</h6><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-2732dbd14b7e04ce36a2b79bd5436e2e_720w.webp" alt="img"></p><ol><li>因为这里只有两个错误</li><li>所以第三个X^e3可以认为是0</li><li>找到这个函数的两个根</li></ol><h6 id="初等对称函数-Elementary-symmetric-polynomial-s"><a href="#初等对称函数-Elementary-symmetric-polynomial-s" class="headerlink" title="初等对称函数(Elementary symmetric polynomial)s"></a>初等对称函数(Elementary symmetric polynomial)s</h6><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027222713543.png" alt="image-20221027222713543"></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-f9e699a8755d88dca5fc7173b922088e_720w.webp" alt="img"></p><p>另定义幂和对称函数（ power sum symmetric functions）t，</p><blockquote><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030235433335.png" alt="image-20221030235433335"></p><p>这里主要使用了power sum symmetric functions幂和对称函数</p></blockquote><h2 id="power-sum-symmetric-functions幂和对称函数"><a href="#power-sum-symmetric-functions幂和对称函数" class="headerlink" title="power sum symmetric functions幂和对称函数"></a>power sum symmetric functions幂和对称函数</h2><blockquote><p>[Symmetric functions Monomial symmetric functions Elementary symmetric functions](<a href="https://www.symmetricfunctions.com/standardSymmetricFunctions.htm#:~:text=Powersum">https://www.symmetricfunctions.com/standardSymmetricFunctions.htm#:~:text=Powersum</a> symmetric functions The powersum symmetric functions are,an orthogonal basis for the Hall inner product.)</p></blockquote><h2 id="Symmetric-functions对称函数"><a href="#Symmetric-functions对称函数" class="headerlink" title="Symmetric functions对称函数"></a>Symmetric functions对称函数</h2><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031000232255.png" alt="image-20221031000232255"></p><p>对于任意排列的w∈Sn<br>$$<br>f(x1,x2,…,xn)&#x3D;f(xw(1),xw(2),…,xw(n))<br>$$</p><h2 id="Monomial-symmetric-functions单项式对称函数"><a href="#Monomial-symmetric-functions单项式对称函数" class="headerlink" title="Monomial symmetric functions单项式对称函数"></a>Monomial symmetric functions单项式对称函数</h2><p>对于一个范围的λ我们定义其函数为</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031001006131.png" alt="image-20221031001006131"></p><p>如果<img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031001033532.png" alt="image-20221031001033532">是<img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031000934322.png" alt="image-20221031000934322">范围的一部分，那么就可以定义其为augmented monomial symmetric functions</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031001152122.png" alt="image-20221031001152122"></p><p>where</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031001205480.png" alt="image-20221031001205480"></p><p>更多请看此链接<a href="http://dx.doi.org/10.1186/s40064-015-1506-5">http://dx.doi.org/10.1186/s40064-015-1506-5</a></p><h2 id="Elementary-symmetric-functions"><a href="#Elementary-symmetric-functions" class="headerlink" title="Elementary symmetric functions"></a>Elementary symmetric functions</h2><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031002235040.png" alt="image-20221031002235040"></p><h2 id="Powersum-symmetric-functions"><a href="#Powersum-symmetric-functions" class="headerlink" title="Powersum symmetric functions"></a>Powersum symmetric functions</h2><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031003237660.png" alt="image-20221031003237660"></p><p>They serve as an orthogonal basis for the <a href="https://www.symmetricfunctions.com/schur.htm#schurInnerProduct">Hall inner product</a>. We have the following product expansions [Sec. 1.4, <a href="https://www.symmetricfunctions.com/standardSymmetricFunctions.htm#Macdonald1995">Mac95</a>] (see the <a href="https://www.symmetricfunctions.com/preliminaries.htm#prelimPartitionStatistics">preliminaries</a> for the definition of zλ).</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031005515331.png" alt="image-20221031005515331"></p><h5 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h5><p><a href="https://www.symmetricfunctions.com/standardQuasiSymmetricFunctions.htm#qPsi">https://www.symmetricfunctions.com/standardQuasiSymmetricFunctions.htm#qPsi</a></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221031005525968.png" alt="image-20221031005525968"></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-98ed54e945b225fe3f45cc19f58cbf37_720w.webp" alt="img"></p><p>例子中，可能有三个错误，于是可表示成：</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-bc7cffd3138d8584f92e54fdf9c579b0_720w.webp" alt="img"></p><p>我们有s与t的关系：</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-6fca53b784fc8b1a427f1c298c1d7393_720w.webp" alt="img"></p><p>此时上面的错误定位不等式就可以用s函数来描述：</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-8c9fed6bddba4647150d8a9b0eb63451_720w.webp" alt="img"></p><p>我们知道一些t的结果：</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-6a61c5f97d988257e48919574ae3fe59_720w.webp" alt="img"></p><p>再用s和t的关系计算</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-3d7405a9bb79ddd2120e0221be1d7a0d_720w.webp" alt="img"></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/v2-38bb301de659478dcc54efc342f7dcfe_720w.webp" alt="img"></p><p>这里st之间用到了初等对称函数，相对来说求解过程比较难理解</p><h2 id="建议看原网页"><a href="#建议看原网页" class="headerlink" title="建议看原网页"></a>建议看原网页</h2><p><a href="https://math.mit.edu/~djk/18.310/18.310F04/bch_codes.html">11. BCH Codes: Constructing them and finding the Syndrome of a Message (mit.edu)</a></p><p>主要是这句</p><blockquote><p>The k-th elementary symmetric function of d elements is defined as the sum of the products of k different elements from among the d elements, combined in all possible ways. </p><p>d 元素的第 k 个基本对称函数定义为<br>从D元素中得到K个不同元素的乘积，尽可能组合在一起<br>方式。</p><p>e, the 2nd elementary function of a, b, c, d is ab+ac+ad+bc+bd+cd.</p><p>e，a，b，c，d的第二个初等函数是ab+ac+ad+bc+bd+cd。</p><p>There is a linear relationship between the elementary symmetric functions and the odd power sums, ti , of the error monomials. The coefficients, sj, 1 ≤ j ≤ k of the error locator polynomial are related to the ti ’s in the following for k odd and s0 &#x3D; t0 &#x3D; 1</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030235014380.png" alt="image-20221030235014380"></p></blockquote><h6 id="对称函数及初等对称函数【补】"><a href="#对称函数及初等对称函数【补】" class="headerlink" title="对称函数及初等对称函数【补】"></a>对称函数及初等对称函数【补】</h6><p>对称函数就是对称的函数（symmetric functions）</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221027224219024.png" alt="image-20221027224219024"></p><p>对称函数对加法和乘法封闭</p><h3 id="Hanming-code-implementing"><a href="#Hanming-code-implementing" class="headerlink" title="Hanming code implementing"></a>Hanming code implementing</h3><h6 id="Hamming（7，4）的硬件实现"><a href="#Hamming（7，4）的硬件实现" class="headerlink" title="Hamming（7，4）的硬件实现"></a>Hamming（7，4）的硬件实现</h6><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030223938066.png"></p><p>早期的Hamming（7，4）形式如上</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030230007921.png"></p><p>下边使用异或门的硬件实现</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030224253221.png" alt="image-20221030224253221"></p><p>这是早期的Hamming（7，4）形式</p><h6 id="汉明码理解【补】"><a href="#汉明码理解【补】" class="headerlink" title="汉明码理解【补】"></a>汉明码理解【补】</h6><p>（英文阅读）</p><p><a href="https://www.bilibili.com/video/BV1WK411N7kz/?spm_id_from=333.999.0.0&vd_source=5f8dc99b785171c1c1179ddedc4c195c">【官方双语】汉明码Pa■t1，如何克服噪■_哔哩哔哩_bilibili</a></p><h6 id="Error-correction"><a href="#Error-correction" class="headerlink" title="Error correction"></a>Error correction</h6><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028185621483.png" alt="image-20221028185621483"></p><p>we all need to be concerned about Redundancy.</p><p>balance data and redundancy.</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028190019192.png" alt="image-20221028190019192"></p><p>the hamming code having them sit in positions that are powers of 2 allows for something really elegant by the end.</p><p>Also in this picture, you will find out there’s a mild nuance for what goes on in position 0 .</p><p>from sender to receiver it will possible to have Potential noise.</p><p>Before we diving it, we need to talk about the idea which was fresh on Hamming’s mind at the time of his discovery.</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028204558420.png" alt="image-20221028204558420"></p><h5 id="Parity-check"><a href="#Parity-check" class="headerlink" title="Parity check"></a>Parity check</h5><p>For a parity check, we separate only one single bit that the sender is responsible for tuning.</p><h6 id="And-what-about-rest"><a href="#And-what-about-rest" class="headerlink" title="And what about rest?"></a>And what about rest?</h6><p>The rest will be free to carry a message.</p><h6 id="And-what-use-of-the-single-bit"><a href="#And-what-use-of-the-single-bit" class="headerlink" title="And what use of the single bit?"></a>And what use of the single bit?</h6><p>It’s to make sure the total number of 1’s in the message is an even number.</p><h6 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h6><p>with the noise making a single one-bit from 0 change to 1, the receiver will find the parity is odd, which is typically more helpful once you start doing math with the idea.</p><p>And this special bit that the sender uses to control the parity is called a “parity bit”</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028210257754.png" alt="image-20221028210257754"></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028203736185.png" alt="image-20221028203736185"></p><h6 id="What-about-3-errors-or-any-other-odd-number"><a href="#What-about-3-errors-or-any-other-odd-number" class="headerlink" title="What about 3 errors, or any other odd number?"></a>What about 3 errors, or any other odd number?</h6><p>But they can know for sure that it wasn’t a 0 error.</p><p>On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1’s would still be even, so the receiver can’t have full confidence that an even count necessarily means the message is error-free.</p><h6 id="Messed-up-by-only-two-bit-flips-is-pretty-weak"><a href="#Messed-up-by-only-two-bit-flips-is-pretty-weak" class="headerlink" title="Messed up by only two-bit flips is pretty weak?"></a>Messed up by only two-bit flips is pretty weak?</h6><p>But we all need to know, there is no method for error detection, or correction, that could give you 100% confidence.</p><p>why?</p><p>Because enough random noise has the ability to change one valid message into another valid message.</p><p>Instead, the goal is to come up with a scheme that’s robust up to a certain maximum number of errors.</p><h6 id="Identify-where-the-error-happened"><a href="#Identify-where-the-error-happened" class="headerlink" title="Identify where the error happened."></a>Identify where the error happened.</h6><p>Let’s take this(4*4)image as an example ,we divide the original image into 4 parts，4 parts have it’s own redundant code.</p><p>The four redundant codes distinguish the rows and columns separately.</p><p>Just enjoy taking a moment to convince yourself that the answsers four parts really will always let you pin down a specific position.</p><p>If you look carefully here, you might find the connection between these question and binary counting.</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028211738256.png" alt="image-20221028211738256"></p><h6 id="17th-outcome"><a href="#17th-outcome" class="headerlink" title="17th outcome"></a>17th outcome</h6><p>You see, with four yes or no questions, we have 16 possible outcomes for our parity checks.</p><p>下边内容相对来说比较难理解，还是用中文表达了</p><blockquote><h6 id="第17种可能–没错误的情形"><a href="#第17种可能–没错误的情形" class="headerlink" title="第17种可能–没错误的情形"></a>第17种可能–没错误的情形</h6><p>如果我们四位奇偶校验全部通过，没有错误，那这种情形怎么办？</p><p>因为我们前边四个冗余码成功的奇偶校验了4*4个方格的位置，也就是16种有一个位置发生错误的情况，那我们这个数据如果没有错误的这个情况用什么表示？</p><p>解决方案异常简单，就直接忽略0位</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028213513415.png" alt="image-20221028213513415"></p><p>就是说我们只用15bit的内容进行奇偶校验，11位用来携带信息，4位作为冗余的控制位</p><p>这就是业内人士说的（15，11）汉明码</p><p>扩展汉明码（Extend Hamming Code）</p><p>如果我们使用这个第一位进行一个新的奇偶校验位，那我们就可以检测出2两个错误位，但是不能修复他</p><h6 id="实际信息"><a href="#实际信息" class="headerlink" title="实际信息"></a>实际信息</h6><p>我们实际的信息通常是进行数据分割，每部分11-bit</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028214213765.png" alt="image-20221028214213765"></p><p>每个块放入一个16bit的 error-resistant 块中</p><p>eg.奇偶性为偶例子</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028214312190.png" alt="image-20221028214312190"></p><p>拍去冗余位，将数据位放入</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028214505712.png" alt="image-20221028214505712"></p><p>第一组：2^0</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028214612203.png" alt="image-20221028214612203"></p><p>第二组：2^1</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028214700338.png" alt="image-20221028214700338"></p><p>第三组：2^2</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028214738542.png" alt="image-20221028214738542"></p><p>第四组：2^3</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028215014108.png" alt="image-20221028215014108"></p><p>最后把整体0号位为偶</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028215104585.png" alt="image-20221028215104585"></p><p>思想相对来说不是很难</p><p>但是我们究其本质，是极其的优雅，将数据进行1-15的二值化，可以看出</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028220529923.png" alt="image-20221028220529923"></p><p>不同位上是否位01决定了我们的四个PART的区域</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028220621230.png" alt="image-20221028220621230"></p><p>后面我们引入异或的思想（xor）exclusive or</p><p>异或通俗理解就是进行两个的相同比较，相同为0，不同为1</p><p><strong>从数学的角度理解，我们可以看作模2加法（mod 2）</strong></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028221143269.png" alt="image-20221028221143269"></p><p>发送方使得各位异或结果为0000</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221028221235042.png" alt="image-20221028221235042"></p><p>如果有区域变化，那么我们可以通过对数据进行异或操作，特别简单的找到错误的 位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">17278</span>\anaconda3\python.exe <span class="string">&quot;C:\Users\17278\应用程序\PYCHARM\PyCharm 2021.3.2\plugins\python\helpers\pydev\pydevconsole.py&quot;</span> --mode=client --port=<span class="number">10787</span></span><br><span class="line"><span class="keyword">import</span> sys; <span class="built_in">print</span>(<span class="string">&#x27;Python %s on %s&#x27;</span> % (sys.version, sys.platform))</span><br><span class="line">sys.path.extend([<span class="string">&#x27;D:\\Subject\\四维码&#x27;</span>, <span class="string">&#x27;D:/Subject/四维码&#x27;</span>])</span><br><span class="line">Python <span class="number">3.9</span><span class="number">.7</span> (default, Sep <span class="number">16</span> <span class="number">2021</span>, <span class="number">16</span>:<span class="number">59</span>:<span class="number">28</span>) [MSC v<span class="number">.1916</span> <span class="number">64</span> bit (AMD64)]</span><br><span class="line"><span class="type">Type</span> <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">7.29</span><span class="number">.0</span> -- An enhanced Interactive Python. <span class="type">Type</span> <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line">PyDev console: using IPython <span class="number">7.29</span><span class="number">.0</span></span><br><span class="line">Python <span class="number">3.9</span><span class="number">.7</span> (default, Sep <span class="number">16</span> <span class="number">2021</span>, <span class="number">16</span>:<span class="number">59</span>:<span class="number">28</span>) [MSC v<span class="number">.1916</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">16</span>)</span><br><span class="line">Out[<span class="number">3</span>]: array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">bits=np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">enumerate</span>(bits)</span><br><span class="line">Out[<span class="number">5</span>]: &lt;<span class="built_in">enumerate</span> at <span class="number">0x1e0d2bc5840</span>&gt;</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(bits))</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">11</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">12</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">13</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">14</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">15</span>, <span class="number">1</span>)]</span><br><span class="line">[i <span class="keyword">for</span> i,bit <span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) ]</span><br><span class="line">Out[<span class="number">7</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line">[i <span class="keyword">for</span> i,bit <span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) <span class="keyword">if</span> bit]</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line">bits</span><br><span class="line">Out[<span class="number">9</span>]: array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="number">0</span>^ <span class="number">1</span>^ <span class="number">2</span>^ <span class="number">7</span>^ <span class="number">8</span>^ <span class="number">11</span>^ <span class="number">12</span>^ <span class="number">13</span>^ <span class="number">14</span>^<span class="number">15</span></span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">7</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> operator <span class="keyword">as</span> op</span><br><span class="line">reduce(op.xor,[i <span class="keyword">for</span> i,bit <span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) <span class="keyword">if</span> bit])</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">7</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x,y:x^y,[i <span class="keyword">for</span> i,bit <span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) <span class="keyword">if</span> bit])</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h6 id="RS-py"><a href="#RS-py" class="headerlink" title="RS.py"></a>RS.py</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span>  reduce</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">16</span>)</span><br><span class="line">bits=np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">16</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamming_syndrome</span>(<span class="params">bits</span>):</span><br><span class="line"> <span class="keyword">return</span> reduce(</span><br><span class="line"> <span class="comment">#Reduce by xor</span></span><br><span class="line"> <span class="keyword">lambda</span> x,y: x^y,</span><br><span class="line"> <span class="comment">#All indices of active bits..-</span></span><br><span class="line"> [i <span class="keyword">for</span> (i,b)<span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) <span class="keyword">if</span> b]</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hamming_syndrome(bits))</span><br></pre></td></tr></table></figure><h5 id="something-Interesting-of-efficiency"><a href="#something-Interesting-of-efficiency" class="headerlink" title="something Interesting of  efficiency"></a>something Interesting of  efficiency</h5><p>Comparing the two image , It is not difficult to see that when the larger the matrix data block, the less error correction code we need ,So the efficiency of this scheme is  better.</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030221950554.png" alt="image-20221030221950554"></p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030221926650.png" alt="image-20221030221926650"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一下：详细探究BCH的数学基础，再到Hamming code 的通俗理解，其实是一个从易到难发现问题，再寻找一种简单方法理解问题的过程。相对来说，比较困难的还是那个幂函数对称函数，Powersum symmetric functions，相关论文还是需要继续阅读，这篇文章忙中抽空写了差不多快4天，途中遇到了各种各样的问题，数学层面上的欠缺需要大量阅读来弥补，Turbo code 和 Shor code是接下来一段时间的阅读计划，欢迎各位关注shiyi-ale的github。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「电子产品」Samsung 16g双通道内存组建安全下车</title>
      <link href="/2022/10/30/Samsung-16g%E5%8F%8C%E9%80%9A%E9%81%93%E5%86%85%E5%AD%98%E7%BB%84%E5%BB%BA%E5%AE%89%E5%85%A8%E4%B8%8B%E8%BD%A6/"/>
      <url>/2022/10/30/Samsung-16g%E5%8F%8C%E9%80%9A%E9%81%93%E5%86%85%E5%AD%98%E7%BB%84%E5%BB%BA%E5%AE%89%E5%85%A8%E4%B8%8B%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<p>关于最近组了一个双通道16g3200MHZ的DRAM</p><blockquote><p>PDD下单，1天就送到了，采用机型Dell 5511 </p><p>花费不是很大可以说很香300RMB左右一条，600RMB拿下</p><p>原来那两条2BG海力士是凑合了</p></blockquote><h2 id="拆装教程"><a href="#拆装教程" class="headerlink" title="拆装教程"></a>拆装教程</h2><p><a href="https://www.bilibili.com/video/BV13h411m79S?share_source=copy_web">https://www.bilibili.com/video/BV13h411m79S?share_source=copy_web</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>记得在拆机前放放手上的静电,洗个手或者摸摸大铁门</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030170821916.png" alt="image-20221030170821916"></p><p>双面8颗粒三星相对来说对于3060laptop的释放要好很多</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030170843528.png" alt="image-20221030170843528"></p><p>下面是一些测试</p><p><img src="https://raw.githubusercontent.com/shiyi-ale/Image/main/Blog/image-20221030165931675.png" alt="image-20221030165931675"></p><h3 id="三星内存条不乏有手艺人的存在，从外观辨别可以看这个视频"><a href="#三星内存条不乏有手艺人的存在，从外观辨别可以看这个视频" class="headerlink" title="三星内存条不乏有手艺人的存在，从外观辨别可以看这个视频"></a>三星内存条不乏有手艺人的存在，从外观辨别可以看这个视频</h3><p><a href="https://www.bilibili.com/video/BV1SY4y1p7TL?share_source=copy_web">https://www.bilibili.com/video/BV1SY4y1p7TL?share_source=copy_web</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DRAM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
